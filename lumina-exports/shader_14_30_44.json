{
  "name": "Shader-14:30:44",
  "prompt": "Procedural Shader Snapshot",
  "code": "uniform float iTime;\nuniform vec2 iResolution;\nuniform vec4 iMouse;\nuniform sampler2D iChannel0;\n\n// User Parameters\nuniform float u_speed;\nuniform float u_camera_dist;\nuniform float u_fov;\nuniform float u_glow_intensity;\nuniform float u_twist;\n\nout vec4 fragColor;\n\n// --- UTILS ---\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Smooth minimum for organic merging\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Palette generator by Inigo Quilez\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// --- GEOMETRY ---\n// The Infinity Curve (Lemniscate of Bernoulli inspired 3D path)\nvec3 getInfinityPos(float t) {\n    float x = cos(t);\n    float y = sin(2.0 * t) * 0.4;\n    float z = sin(t);\n    return vec3(x, y, z) * 3.5;\n}\n\nfloat map(vec3 p) {\n    float d = 1e10;\n    \n    // We sample the curve at several points near the projection to find the closest distance\n    // For a smoother \"ribbon\" look, we use a loop or a simplified parametric SDF\n    for(float i = 0.0; i < 1.0; i += 0.1) {\n        float t = i * 6.28318 + (iTime * 0.1);\n        vec3 pos = getInfinityPos(t);\n        \n        // Add some local twisting\n        vec3 q = p - pos;\n        q.xy *= rot(t * u_twist + iTime);\n        \n        float box = length(q) - 0.25; // Base thickness\n        d = smin(d, box, 0.8);\n    }\n    \n    // Add a central core glow sphere\n    float core = length(p) - 0.5;\n    d = smin(d, core, 1.5);\n    \n    return d;\n}\n\n// Normal calculation\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid main() {\n    // 1. Correct Aspect Ratio UVs\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // 2. Camera Setup (Parallel Rail Strategy)\n    float t = iTime * u_speed * 0.2;\n    \n    // Orbiting Camera\n    vec3 ro = vec3(sin(t) * u_camera_dist, cos(t * 0.5) * 2.0, cos(t) * u_camera_dist);\n    vec3 ta = vec3(0.0, 0.0, 0.0); // Look at center\n    \n    // Mouse interaction\n    if(iMouse.z > 0.0) {\n        float mx = (iMouse.x / iResolution.x - 0.5) * 10.0;\n        ro.xz *= rot(mx);\n    }\n\n    vec3 f = normalize(ta - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n    vec3 rd = normalize(f * u_fov + uv.x * r + uv.y * u);\n\n    // 3. Raymarching\n    float dO = 0.0;\n    float glow = 0.0;\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 80; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = map(p);\n        \n        // Accumulate glow based on proximity to surface\n        glow += exp(-dS * 2.0);\n        \n        if(dO > 30.0 || dS < 0.001) break;\n        dO += dS * 0.8; // Step size\n    }\n\n    // 4. Shading\n    if(dO < 30.0) {\n        vec3 p = ro + rd * dO;\n        vec3 n = getNormal(p);\n        vec3 lightPos = vec3(5.0, 5.0, 5.0);\n        vec3 l = normalize(lightPos - p);\n        \n        // Lighting components\n        float diff = max(dot(n, l), 0.0);\n        float spec = pow(max(dot(reflect(-l, n), -rd), 0.0), 32.0);\n        float fresnel = pow(1.0 + dot(rd, n), 4.0);\n        \n        // Base gradient color based on position\n        vec3 baseCol = palette(length(p) * 0.1 + iTime * 0.1);\n        \n        col = baseCol * diff;\n        col += spec * 0.5;\n        col += baseCol * fresnel * 0.8;\n        \n        // Smooth fade into distance\n        col = mix(col, vec4(0.02, 0.01, 0.05, 1.0).rgb, smoothstep(0.0, 30.0, dO));\n    } else {\n        // Background subtle gradient\n        col = vec3(0.01, 0.01, 0.03) * (1.0 - length(uv));\n    }\n\n    // 5. Post-Processing (Glow and Color Grading)\n    vec3 glowCol = palette(iTime * 0.05) * glow * 0.05 * u_glow_intensity;\n    col += glowCol;\n    \n    // Contrast and Tone Mapping\n    col = smoothstep(-0.05, 1.1, col);\n    col = pow(col, vec3(0.85)); // Slight gamma correction\n    \n    fragColor = vec4(col, 1.0);\n}",
  "parameters": [
    {
      "name": "u_speed",
      "label": "Animation Speed",
      "type": "float",
      "default": 1.5,
      "min": 0,
      "max": 5
    },
    {
      "name": "u_camera_dist",
      "label": "Camera Distance",
      "type": "float",
      "default": 10,
      "min": 5,
      "max": 20
    },
    {
      "name": "u_fov",
      "label": "Field of View",
      "type": "float",
      "default": 1.94,
      "min": 0.5,
      "max": 2.5
    },
    {
      "name": "u_glow_intensity",
      "label": "Glow Strength",
      "type": "float",
      "default": 0.6,
      "min": 0,
      "max": 2
    },
    {
      "name": "u_twist",
      "label": "Ribbon Twist",
      "type": "float",
      "default": 2,
      "min": 0,
      "max": 10
    }
  ],
  "textureUrl": null
}