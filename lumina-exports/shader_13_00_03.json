{
  "name": "Shader-13:00:03",
  "prompt": "Procedural Shader Snapshot",
  "code": "\n\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec4 iMouse;\nuniform sampler2D iChannel0;\n\n// Parameters via JSON:\nuniform float u_speed;\nuniform float u_fov;\nuniform float u_camera_dist;\nuniform float u_morph;\n\nout vec4 fragColor;\n\n// --- UTILS ---\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Cheap noise for volumetric effects\nfloat hash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\n// --- WORLD LOGIC ---\n\n// The \"Universe Path\" for the parallel rail system\nvec2 getPath(float z) {\n    return vec2(sin(z * 0.2) * 2.5, cos(z * 0.15) * 2.0);\n}\n\n// Distance Function\nfloat map(vec3 p) {\n    // 1. Position relative to path\n    p.xy -= getPath(p.z);\n    \n    // Create a repeating spatial lattice\n    vec3 p_grid = p;\n    float interval = 8.0;\n    float id = floor(p_grid.z / interval);\n    p_grid.z = mod(p_grid.z, interval) - interval * 0.5;\n    \n    // Rotate individual segments for surreal feel\n    p_grid.xy *= rot(iTime * 0.2 + id);\n    p_grid.xz *= rot(iTime * 0.1);\n\n    // Fractal Morphing Object\n    float d = 1e10;\n    vec3 q = p_grid;\n    float s = 1.0;\n    \n    // Iterative folding (Sierpinski/Menger hybrid influence)\n    for(int i = 0; i < 4; i++) {\n        q = abs(q) - 0.5 * u_morph;\n        q.xy *= rot(0.5);\n        q.yz *= rot(0.3);\n        s *= 1.4;\n        q *= 1.4;\n    }\n    \n    float shape1 = sdBox(q, vec3(1.0)) / s;\n    float shape2 = length(q) / s - 0.5;\n    \n    d = mix(shape1, shape2, sin(iTime * 0.5) * 0.5 + 0.5);\n    \n    // Add a central \"Core\" strand\n    float core = length(p.xy) - 0.2;\n    d = min(d, core);\n    \n    return d * 0.8; // Step scaling for safety\n}\n\n// Simple Normal calculation\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Speed and Pathing\n    float t = iTime * u_speed;\n    \n    // 1. Path Position (The center of the world)\n    vec3 pathPos = vec3(0.0, 0.0, t);\n    pathPos.xy += getPath(pathPos.z);\n    \n    // 2. PARALLEL RAIL SYSTEM\n    // The camera orbits the path while moving along it\n    float angle = t * 0.1;\n    vec2 railVec = vec2(cos(angle), sin(angle)) * u_camera_dist;\n    \n    vec3 ro = pathPos;\n    ro.xy += railVec; \n\n    // 3. TARGET (Look ahead, slightly inward to keep geometry in view)\n    vec3 ta = vec3(0.0, 0.0, t + 10.0);\n    ta.xy += getPath(ta.z) + railVec * 0.5; \n    \n    // Camera Setup\n    vec3 fwd = normalize(ta - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), fwd));\n    vec3 up = cross(fwd, right);\n    vec3 rd = normalize(fwd * u_fov + uv.x * right + uv.y * up);\n    \n    // Raymarching Loop\n    float d = 0.0, t_dist = 0.0;\n    float glow = 0.0;\n    vec3 p;\n    \n    for(int i = 0; i < 100; i++) {\n        p = ro + rd * t_dist;\n        d = map(p);\n        if(d < 0.001 || t_dist > 60.0) break;\n        t_dist += d;\n        // Accumulate glow based on proximity\n        glow += exp(-d * 4.0);\n    }\n    \n    // Coloring\n    vec3 col = vec3(0.0);\n    \n    if(t_dist < 60.0) {\n        vec3 n = getNormal(p);\n        vec3 lightDir = normalize(vec3(1.0, 2.0, -1.0));\n        float diff = max(dot(n, lightDir), 0.0);\n        float fresnel = pow(1.0 + dot(rd, n), 4.0);\n        \n        // Base color driven by depth and normals\n        vec3 baseCol = 0.5 + 0.5 * cos(vec3(0.0, 1.0, 2.0) + p.z * 0.1);\n        col = baseCol * diff;\n        col += fresnel * vec3(0.5, 0.8, 1.0); // Icy rim light\n        \n        // Fog/Depth attenuation\n        col = mix(col, vec3(0.02, 0.01, 0.05), 1.0 - exp(-0.02 * t_dist));\n    } else {\n        // Background / Stars\n        col = vec3(0.01, 0.01, 0.03);\n        float stars = pow(hash(rd * 500.0), 100.0);\n        col += stars;\n    }\n    \n    // Post-processing: Add Procedural Glow\n    col += glow * 0.02 * vec3(0.6, 0.2, 0.9);\n    \n    // Cinematic Vignette\n    col *= 1.0 - length(uv) * 0.5;\n    \n    // Tone mapping\n    col = smoothstep(0.0, 1.0, col);\n    col = pow(col, vec3(0.4545)); // Gamma correction\n\n    fragColor = vec4(col, 1.0);\n}",
  "parameters": [
    {
      "name": "u_speed",
      "label": "Fly Speed",
      "type": "float",
      "default": 4,
      "min": 0,
      "max": 10
    },
    {
      "name": "u_camera_dist",
      "label": "Orbit Distance",
      "type": "float",
      "default": 6.68,
      "min": 2,
      "max": 15
    },
    {
      "name": "u_fov",
      "label": "Field of View",
      "type": "float",
      "default": 1.2,
      "min": 0.5,
      "max": 2.5
    },
    {
      "name": "u_morph",
      "label": "Morph Intensity",
      "type": "float",
      "default": 2.5,
      "min": 0.5,
      "max": 5
    }
  ],
  "textureUrl": null
}