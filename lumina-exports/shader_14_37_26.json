{
  "name": "Shader-14:37:26",
  "prompt": "Procedural Shader Snapshot",
  "code": "\n\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec4 iMouse;\nuniform sampler2D iChannel0;\n\n// User-defined parameters via JSON\nuniform float u_speed;\nuniform float u_fov;\nuniform float u_camera_dist;\nuniform float u_fractal_complexity;\nuniform float u_glow_intensity;\n\nout vec4 fragColor;\n\n// --- UTILS ---\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// --- FRACTAL ENGINE ---\n// Inspired by Mandelbox/IFS logic for tech-like circuitry\nfloat map(vec3 p) {\n    float d = 1e10;\n    \n    // Create a repeating lattice\n    vec3 p_lattice = p;\n    float cell = 4.0;\n    p_lattice.z = mod(p_lattice.z, cell) - cell * 0.5;\n    \n    // Fractal Iterations\n    vec3 q = p_lattice;\n    float scale = 1.0;\n    \n    for(int i = 0; i < 4; i++) {\n        q = abs(q) - vec3(0.5, 0.8, 0.4);\n        q.xy *= rot(0.5 + float(i) * 0.2);\n        q.yz *= rot(0.3);\n        \n        // Mirroring and Scaling\n        float s = 1.8 / clamp(dot(q, q), 0.3, 1.2);\n        q *= s;\n        scale *= s;\n    }\n    \n    // Geometry: Thin plates and wires\n    float wires = length(q.xy) / scale - 0.002;\n    float plates = sdBox(q, vec3(1.5, 0.05, 1.2)) / scale;\n    \n    return min(wires, plates);\n}\n\n// --- LIGHTING ---\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid main() {\n    // 1. Setup Coordinates\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float time = iTime * u_speed * 0.2;\n    \n    // 2. Parallel Rail Camera System\n    // We move along Z, but orbit around the center structure\n    float z_pos = time * 5.0;\n    vec3 pathPos = vec3(0.0, 0.0, z_pos);\n    \n    // Camera orbital movement\n    float angle = time * 0.3;\n    vec2 railVec = vec2(cos(angle), sin(angle)) * u_camera_dist;\n    \n    vec3 ro = pathPos;\n    ro.xy += railVec;\n    \n    // Target look-ahead\n    vec3 ta = vec3(0.0, 0.0, z_pos + 10.0);\n    ta.xy += railVec * 0.7; // Look slightly inward to see the fractal structure passing by\n    \n    // Construct Ray\n    vec3 fwd = normalize(ta - ro);\n    vec3 right = normalize(cross(vec3(0, 1, 0), fwd));\n    vec3 up = cross(fwd, right);\n    vec3 rd = normalize(fwd * u_fov + uv.x * right + uv.y * up);\n    \n    // 3. Raymarching (Volumetric/Transparent Style)\n    vec3 color = vec3(0.0);\n    float t = 0.0;\n    float glow = 0.0;\n    float transparency = 1.0;\n    \n    for(int i = 0; i < 80; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        \n        // Accumulate \"tech glow\" based on proximity\n        float g = 0.01 / (0.02 + abs(d));\n        glow += g;\n        \n        // If we hit a surface (or get very close)\n        if(d < 0.002) {\n            vec3 n = getNormal(p);\n            float fresnel = pow(1.0 - max(0.0, dot(-rd, n)), 3.0);\n            \n            // Electronic Cyan/Blue palette\n            vec3 surfCol = vec3(0.1, 0.5, 1.0) * fresnel * 2.0;\n            color += surfCol * transparency;\n            \n            // Thin surface behavior: don't stop immediately, fade out\n            transparency *= 0.8;\n            d = 0.05; // Step forward to find next layer\n            if(transparency < 0.05) break;\n        }\n        \n        t += max(d * 0.5, 0.01);\n        if(t > 30.0) break;\n    }\n    \n    // 4. Final Color Composition\n    // Add glowing \"void\" color\n    vec3 glowCol = vec3(0.05, 0.15, 0.3) * glow * u_glow_intensity;\n    color += glowCol;\n    \n    // Tech Grid Background\n    float grid = (sin(uv.x * 50.0) * sin(uv.y * 50.0));\n    color += vec3(0.2, 0.4, 0.8) * pow(grid, 10.0) * 0.05;\n    \n    // Atmospheric fog\n    color = mix(color, vec3(0.005, 0.01, 0.02), 1.0 - exp(-0.05 * t));\n    \n    // Post-processing\n    color = pow(color, vec3(0.8)); // Gamma correction\n    color *= 1.2 - dot(uv, uv);    // Vignette\n    \n    fragColor = vec4(color, 1.0);\n}",
  "parameters": [
    {
      "name": "u_speed",
      "label": "Fly Speed",
      "type": "float",
      "default": 1,
      "min": 0,
      "max": 5
    },
    {
      "name": "u_fov",
      "label": "Field of View",
      "type": "float",
      "default": 1.2,
      "min": 0.5,
      "max": 2.5
    },
    {
      "name": "u_camera_dist",
      "label": "Rail Distance",
      "type": "float",
      "default": 5.5,
      "min": 2,
      "max": 10
    },
    {
      "name": "u_glow_intensity",
      "label": "Glow Brightness",
      "type": "float",
      "default": 0.4,
      "min": 0,
      "max": 1.5
    },
    {
      "name": "u_fractal_complexity",
      "label": "Fractal Iterations",
      "type": "float",
      "default": 4,
      "min": 1,
      "max": 8
    }
  ],
  "textureUrl": null
}