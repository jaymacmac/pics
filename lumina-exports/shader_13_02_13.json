{
  "name": "Shader-13:02:13",
  "prompt": "Procedural Shader Snapshot",
  "code": "\n\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec4 iMouse;\nuniform sampler2D iChannel0;\n\n// User Parameters\nuniform float u_speed;\nuniform float u_fov;\nuniform float u_camera_dist;\nuniform float u_morph;\n\nout vec4 fragColor;\n\n/**\n * Procedural Surrealism: \"The Whispering Monoliths\"\n * A sequence of shifting, impossible geometries floating in a volumetric void.\n * Uses raymarching, fractal folding, and rhythmic color cycles.\n */\n\n// Math Constants\n#define PI 3.14159265359\n#define MAX_STEPS 100\n#define SURF_DIST 0.001\n#define MAX_DIST 100.0\n\n// Rotation matrix\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Smooth Minimum (Polynominal)\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Path for the camera and geometry to follow\nvec2 getPath(float z) {\n    return vec2(sin(z * 0.15), cos(z * 0.1)) * 3.5;\n}\n\n// Fractal Fold\nvoid fractalFold(inout vec3 p) {\n    for(int i = 0; i < 3; i++) {\n        p.xy = abs(p.xy) - 0.5;\n        p.xy *= rot(0.5 + iTime * 0.1);\n        p.yz = abs(p.yz) - 0.2;\n        p.yz *= rot(-0.3);\n    }\n}\n\n// Scene SDF\nfloat map(vec3 p) {\n    vec2 path = getPath(p.z);\n    p.xy -= path; // Universe centering\n    \n    vec3 p1 = p;\n    // Spiral twist\n    p1.xy *= rot(p.z * 0.2 + iTime * 0.2);\n    \n    // The \"Central Structure\" - A floating surreal ribbon/tower\n    fractalFold(p1);\n    \n    // Create repeating structures along Z\n    float z_cycle = mod(p1.z, 4.0) - 2.0;\n    vec3 p_box = vec3(p1.x, p1.y, z_cycle);\n    \n    // Box shape\n    vec3 d = abs(p_box) - vec3(0.4, 0.8, 0.2);\n    float box = length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Spheres morphing\n    float sphere = length(p_box) - (0.6 + 0.2 * sin(iTime + p.z));\n    \n    float d1 = mix(box, sphere, 0.5 + 0.5 * sin(iTime * 0.5 + p.z * 0.1));\n    \n    // Background \"clouds\" or pillars\n    float pillars = length(mod(p.xy + 10.0, 20.0) - 10.0) - 1.5;\n    \n    return smin(d1, pillars, 1.5);\n}\n\n// Normal Calculation\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float t = iTime * u_speed;\n    \n    // --- Parallel Rail Camera Logic ---\n    vec3 pathPos = vec3(0.0, 0.0, t);\n    pathPos.xy += getPath(pathPos.z);\n    \n    float railOffset = u_camera_dist;\n    // Subtle rotation of the camera rail around the center path\n    vec2 railVec = vec2(cos(t * 0.1), sin(t * 0.1)) * railOffset;\n    \n    vec3 ro = pathPos; \n    ro.xy += railVec; // Place camera on the rail\n    \n    vec3 ta = vec3(0.0, 0.0, t + 8.0); \n    ta.xy += getPath(ta.z) + railVec * 0.6; // Look slightly towards path but keep distance\n    \n    // Camera Basis\n    vec3 f = normalize(ta - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n    vec3 rd = normalize(f * u_fov + uv.x * r + uv.y * u);\n    \n    // --- Raymarching ---\n    float d = 0.0;\n    float t_dist = 0.0;\n    vec3 p;\n    float glow = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        p = ro + rd * t_dist;\n        d = map(p);\n        \n        // Volumetric glow accumulation\n        glow += 0.01 / (0.01 + abs(d));\n        \n        if(abs(d) < SURF_DIST || t_dist > MAX_DIST) break;\n        t_dist += d * 0.7; // Relaxed step for smoother fractals\n    }\n    \n    // --- Shading ---\n    vec3 col = vec3(0.0);\n    \n    if(t_dist < MAX_DIST) {\n        vec3 n = getNormal(p);\n        vec3 lightPos = ro + vec3(0, 5, 0);\n        vec3 l = normalize(lightPos - p);\n        \n        float diff = clamp(dot(n, l), 0.0, 1.0);\n        float amb = 0.5 + 0.5 * n.y;\n        float spec = pow(clamp(dot(reflect(-l, n), -rd), 0.0, 1.0), 32.0);\n        \n        // Dynamic Palette based on Z depth and time\n        vec3 palette = 0.5 + 0.5 * cos(vec3(0, 2, 4) + p.z * 0.2 + iTime);\n        \n        col = palette * (diff + amb) + spec;\n        \n        // Fresnel\n        float fres = pow(1.0 - max(0.0, dot(n, -rd)), 5.0);\n        col += fres * palette;\n    }\n    \n    // Fog and Atmospheric Glow\n    float fog = 1.0 - exp(-0.02 * t_dist);\n    vec3 skyCol = vec3(0.02, 0.01, 0.05) + 0.1 * vec3(sin(iTime), cos(iTime), 1.0);\n    col = mix(col, skyCol, fog);\n    \n    // Add procedural glow (the \"whispers\")\n    col += glow * 0.02 * vec3(0.4, 0.7, 1.0);\n    \n    // Post Processing\n    col = pow(col, vec3(0.85)); // Gamma Correction-ish\n    col *= 1.0 - dot(uv, uv) * 0.4; // Vignette\n    \n    fragColor = vec4(col, 1.0);\n}",
  "parameters": [
    {
      "name": "u_speed",
      "label": "Fly Speed",
      "type": "float",
      "default": 1.5,
      "min": 0,
      "max": 5
    },
    {
      "name": "u_fov",
      "label": "Field of View",
      "type": "float",
      "default": 1.2,
      "min": 0.5,
      "max": 2.5
    },
    {
      "name": "u_camera_dist",
      "label": "Rail Distance",
      "type": "float",
      "default": 7,
      "min": 3,
      "max": 12
    },
    {
      "name": "u_morph",
      "label": "Morph Intensity",
      "type": "float",
      "default": 0.5,
      "min": 0,
      "max": 1
    }
  ],
  "textureUrl": null
}