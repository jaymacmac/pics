{
  "name": "Shader-14:28:58",
  "prompt": "Procedural Shader Snapshot",
  "code": "\n\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec4 iMouse;\nuniform sampler2D iChannel0;\n\n// Parameter mappings\nuniform float u_speed;\nuniform float u_fov;\nuniform float u_camera_dist;\nuniform float u_glow_intensity;\n\nout vec4 fragColor;\n\n// 2D Rotation Matrix\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Smooth Minimum for blending shapes\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Universe Path - The world curves slightly to create an infinite feeling\nvec2 getPath(float z) {\n    return vec2(sin(z * 0.12) * 3.5, cos(z * 0.08) * 2.5);\n}\n\n// Distance Field\nfloat map(vec3 p) {\n    // Offset the entire world by the path\n    p.xy -= getPath(p.z);\n    \n    // Create an infinite \"tunnel\" of soft pillars and floating orbs\n    vec3 p_pillars = p;\n    p_pillars.z = mod(p_pillars.z, 8.0) - 4.0;\n    \n    // Soft Cylindrical structures\n    float pillars = length(p_pillars.xz) - 0.4;\n    \n    // Floating smooth spheres\n    vec3 p_spheres = p;\n    p_spheres.z = mod(p_spheres.z + 4.0, 8.0) - 4.0;\n    p_spheres.y += sin(iTime + p.z * 0.5) * 1.5;\n    float spheres = length(p_spheres) - 0.8;\n    \n    // Ground and Ceiling\n    float floorPlane = p.y + 4.0 + sin(p.z * 0.2) * 0.5;\n    float ceilPlane = 4.0 - p.y + cos(p.z * 0.2) * 0.5;\n    \n    float scene = smin(pillars, spheres, 1.5);\n    scene = smin(scene, floorPlane, 2.0);\n    scene = smin(scene, ceilPlane, 2.0);\n    \n    return scene;\n}\n\n// Standard normal calculation\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid main() {\n    // 1. Correct Aspect Ratio UVs\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // 2. Fly-through timing\n    float t = iTime * u_speed;\n    \n    // 3. Parallel Rail Camera Setup\n    vec3 pathPos = vec3(0.0, 0.0, t);\n    pathPos.xy += getPath(pathPos.z);\n    \n    // The Rail: Camera orbits the path center at u_camera_dist\n    vec2 railVec = vec2(sin(t * 0.2), cos(t * 0.2)) * u_camera_dist;\n    \n    vec3 ro = pathPos;\n    ro.xy += railVec;\n    \n    // Target: Look ahead, but maintain the rail perspective\n    vec3 ta = vec3(0.0, 0.0, t + 10.0);\n    ta.xy += getPath(ta.z) + railVec * 0.5; \n    \n    // Camera Basis\n    vec3 fwd = normalize(ta - ro);\n    vec3 right = normalize(cross(vec3(0, 1, 0), fwd));\n    vec3 up = cross(fwd, right);\n    vec3 rd = normalize(fwd * u_fov + uv.x * right + uv.y * up);\n    \n    // 4. Raymarching Loop\n    float d = 0.0;\n    float t_dist = 0.1;\n    float glow = 0.0;\n    \n    for(int i = 0; i < 80; i++) {\n        vec3 p = ro + rd * t_dist;\n        d = map(p);\n        \n        // Accumulate glow based on proximity to surfaces\n        glow += exp(-d * 0.5) * u_glow_intensity;\n        \n        if(d < 0.001 || t_dist > 60.0) break;\n        t_dist += d * 0.6; // Relaxed marching for smoother gradients\n    }\n    \n    // 5. Coloring and Shading\n    vec3 col = vec3(0.0);\n    vec3 p = ro + rd * t_dist;\n    \n    // Base Gradient Colors\n    vec3 skyTop = vec3(0.05, 0.1, 0.2);\n    vec3 skyBottom = vec3(0.4, 0.1, 0.3);\n    vec3 sunColor = vec3(1.0, 0.8, 0.5);\n    \n    if(t_dist < 60.0) {\n        vec3 n = getNormal(p);\n        float diff = max(dot(n, normalize(vec3(1, 2, -1))), 0.0);\n        float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 4.0);\n        \n        // Procedural color based on world position\n        vec3 objCol = mix(vec3(0.1, 0.2, 0.4), vec3(0.6, 0.2, 0.5), sin(p.z * 0.1) * 0.5 + 0.5);\n        objCol = mix(objCol, vec3(1.0), fresnel * 0.5);\n        \n        col = objCol * diff;\n        \n        // Add some \"infinite\" light bounce\n        col += sunColor * pow(diff, 8.0) * 0.5;\n    } else {\n        // Background Gradient\n        col = mix(skyBottom, skyTop, uv.y + 0.5);\n    }\n    \n    // 6. Volumetric Fog & Glowing Atmosphere\n    float fog = 1.0 - exp(-t_dist * 0.04);\n    vec3 fogCol = mix(vec3(0.02, 0.01, 0.05), vec3(0.5, 0.2, 0.4), sin(t * 0.1) * 0.5 + 0.5);\n    col = mix(col, fogCol, fog);\n    \n    // Apply the accumulated proximity glow\n    col += sunColor * glow * 0.02;\n    \n    // 7. Post-Processing: Contrast, Vignette, Film Grain\n    col = smoothstep(-0.05, 1.1, col); // Soft contrast\n    col *= 1.0 - length(uv) * 0.4;     // Vignette\n    \n    // Subtle procedural grain using texture as a noise source\n    float grain = texture(iChannel0, uv * 2.0 + t * 0.1).r;\n    col += (grain - 0.5) * 0.03;\n\n    fragColor = vec4(col, 1.0);\n}",
  "parameters": [
    {
      "name": "u_speed",
      "label": "Fly Speed",
      "type": "float",
      "default": 4,
      "min": 0,
      "max": 15
    },
    {
      "name": "u_camera_dist",
      "label": "Rail Offset",
      "type": "float",
      "default": 2.16,
      "min": 2,
      "max": 10
    },
    {
      "name": "u_fov",
      "label": "Field of View",
      "type": "float",
      "default": 1.2,
      "min": 0.5,
      "max": 2.5
    },
    {
      "name": "u_glow_intensity",
      "label": "Atmospheric Glow",
      "type": "float",
      "default": 0.4,
      "min": 0,
      "max": 1
    }
  ],
  "textureUrl": null
}