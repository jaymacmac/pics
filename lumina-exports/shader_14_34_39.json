{
  "name": "Shader-14:34:39",
  "prompt": "Procedural Shader Snapshot",
  "code": "\n\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec4 iMouse;\nuniform sampler2D iChannel0;\n\n// User parameters\nuniform float u_speed;\nuniform float u_camera_dist;\nuniform float u_grid_density;\nuniform float u_wire_width;\nuniform float u_red_intensity;\n\nout vec4 fragColor;\n\n// 2D Rotation matrix\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Simple hash for noise\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\n// Fractal Brownian Motion for Martian Terrain\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash(i + vec3(0,0,0).xy), hash(i + vec3(1,0,0).xy), u.x),\n               mix(hash(i + vec3(0,1,0).xy), hash(i + vec3(1,1,0).xy), u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    mat2 m = rot(0.37);\n    for (int i = 0; i < 5; i++) {\n        v += a * noise(p);\n        p = m * p * 2.02;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// Distance Function for the Terrain\nfloat map(vec3 p) {\n    float h = fbm(p.xz * 0.4) * 2.5;\n    h += fbm(p.xz * 1.5) * 0.3; // Added detail\n    return p.y + h;\n}\n\n// Calculate normal for lighting\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\n// Grid/Wireframe function\nfloat wireframe(vec3 p, vec3 n) {\n    vec2 uv = p.xz * u_grid_density;\n    vec2 grid = abs(fract(uv - 0.5) - 0.5) / (u_wire_width * u_grid_density);\n    float line = min(grid.x, grid.y);\n    return 1.0 - smoothstep(0.0, 1.0, line);\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // 1. Path & Camera Movement\n    float t = iTime * u_speed;\n    vec3 pathPos = vec3(0.0, 0.0, t);\n    \n    // Rail system: Look ahead but maintain offset height\n    vec3 ro = pathPos + vec3(sin(t * 0.2) * 0.5, u_camera_dist, 0.0);\n    vec3 ta = pathPos + vec3(sin((t + 5.0) * 0.2) * 0.5, u_camera_dist * 0.8, 5.0);\n    \n    // Camera matrix\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = normalize(uv.x * cu + uv.y * cv + 1.5 * cw);\n    \n    // 2. Raymarching\n    float d = 0.0;\n    float t_dist = 0.01;\n    vec3 p;\n    for(int i = 0; i < 100; i++) {\n        p = ro + rd * t_dist;\n        d = map(p);\n        if(d < 0.001 || t_dist > 40.0) break;\n        t_dist += d * 0.6; // Relaxed step for terrain\n    }\n    \n    // 3. Shading\n    vec3 col = vec3(0.0);\n    \n    // Atmospheric \"Matter\" / Stars\n    float stars = pow(hash(uv + floor(iTime * 10.0) * 0.01), 50.0);\n    vec3 spaceMatter = vec3(1.0, 0.4, 0.2) * stars * step(0.999, hash(uv * 100.0));\n    \n    if(t_dist < 40.0) {\n        vec3 n = getNormal(p);\n        float wire = wireframe(p, n);\n        \n        // Base Martian Color\n        vec3 marsRed = vec3(0.8, 0.2, 0.05) * u_red_intensity;\n        vec3 techColor = vec3(1.0, 0.6, 0.1); // Bright orange/gold for wires\n        \n        // Lighting\n        float diff = max(dot(n, normalize(vec3(1, 2, -1))), 0.0);\n        float fres = pow(1.0 + dot(rd, n), 4.0);\n        \n        // Mix terrain and wireframe\n        col = mix(marsRed * diff * 0.2, techColor, wire);\n        col += fres * techColor * 0.5; // Rim glow on wires\n        \n        // Distance Fog\n        col = mix(col, vec3(0.05, 0.01, 0.0), smoothstep(10.0, 40.0, t_dist));\n    } else {\n        // Space Background\n        col = spaceMatter;\n        // Horizon Glow\n        float horizon = smoothstep(0.2, -0.4, rd.y);\n        col += vec3(0.6, 0.1, 0.0) * horizon * 0.5;\n    }\n    \n    // Scanning line effect\n    float scanline = sin(uv.y * 200.0 + iTime * 5.0) * 0.02;\n    col += scanline;\n\n    // Output with subtle vignette\n    float vignette = 1.0 - length(uv * 0.8);\n    fragColor = vec4(col * vignette, 1.0);\n}",
  "parameters": [
    {
      "name": "u_speed",
      "label": "Fly Speed",
      "type": "float",
      "default": 2.5,
      "min": 0,
      "max": 10
    },
    {
      "name": "u_camera_dist",
      "label": "Altitude",
      "type": "float",
      "default": 1.2,
      "min": 0.5,
      "max": 4
    },
    {
      "name": "u_grid_density",
      "label": "Wireframe Density",
      "type": "float",
      "default": 19.9,
      "min": 10,
      "max": 100
    },
    {
      "name": "u_wire_width",
      "label": "Wire Width",
      "type": "float",
      "default": 0.01985,
      "min": 0.005,
      "max": 0.05
    },
    {
      "name": "u_red_intensity",
      "label": "Mars Glow",
      "type": "float",
      "default": 1.4,
      "min": 0.5,
      "max": 3
    }
  ],
  "textureUrl": null
}