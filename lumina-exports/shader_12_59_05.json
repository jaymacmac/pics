{
  "name": "Shader-12:59:05",
  "prompt": "Procedural Shader Snapshot",
  "code": "/**\n * Salvador Dal's Dream Art - Procedural Surrealism\n * A raymarched landscape of melting forms, impossible geometry, and long shadows.\n * Features: Soft-body melting distortions, \"Elephant-leg\" stilts, and ethereal lighting.\n */\n\nout vec4 fragColor;\n\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec4 iMouse;\nuniform sampler2D iChannel0;\n\n// User Parameters (provided via JSON)\nuniform float u_speed;\nuniform float u_camera_dist;\nuniform float u_melt_factor;\nuniform float u_bloom;\n\n// --- Math Utilities ---\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Simple noise for organic texture\nfloat hash(vec2 p) {\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\n// --- Geometry ---\n\n// The \"Melting Clock\" or soft surface\nfloat sdMeltingSurface(vec3 p) {\n    float displacement = sin(p.x * 2.0 + iTime) * 0.1 * u_melt_factor;\n    displacement += cos(p.z * 1.5 - iTime * 0.5) * 0.15 * u_melt_factor;\n    \n    // Main plate\n    vec3 p_clock = p;\n    p_clock.y += displacement;\n    float box = length(max(abs(p_clock) - vec3(1.5, 0.05, 1.0), 0.0)) - 0.1;\n    \n    return box;\n}\n\n// The spindly legs (Stilts)\nfloat sdStilts(vec3 p) {\n    vec2 grid = mod(p.xz + 5.0, 10.0) - 5.0;\n    float d = length(grid) - 0.02 * (p.y + 4.0); // Tapered\n    return max(d, -p.y - 4.0);\n}\n\n// The \"Monolith\" or floating eye structure\nfloat sdFloatingForm(vec3 p) {\n    p.y -= 2.5 + sin(iTime * 0.5) * 0.5;\n    p.xz *= rot(iTime * 0.2);\n    float sphere = length(p) - 1.0;\n    float hole = length(p.yz) - 0.4;\n    return max(sphere, -hole);\n}\n\nfloat map(vec3 p) {\n    // The Ground Plane (Desolate desert)\n    float ground = p.y + 1.0 + sin(p.x * 0.5) * 0.2 * cos(p.z * 0.5);\n    \n    // Melting objects scattered\n    vec3 p_clock = p - vec3(0.0, 0.5, 0.0);\n    p_clock.xy *= rot(0.3);\n    float clock = sdMeltingSurface(p_clock);\n    \n    float stilts = sdStilts(p);\n    float floating = sdFloatingForm(p - vec3(-4.0, 0.0, 5.0));\n    \n    return smin(ground, smin(clock, smin(stilts, floating, 0.2), 0.1), 0.2);\n}\n\n// --- Rendering ---\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nfloat getShadow(vec3 ro, vec3 rd) {\n    float res = 1.0;\n    float t = 0.01;\n    for(int i=0; i<32; i++) {\n        float h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.5);\n        if(res < 0.01 || t > 15.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float t = iTime * u_speed * 0.1;\n    \n    // Path and Camera Rail\n    vec3 ro = vec3(cos(t) * u_camera_dist, 2.0 + sin(t * 0.5), sin(t) * u_camera_dist);\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n    \n    // Mouse Interaction\n    if(iMouse.z > 0.0) {\n        ro.yz *= rot((iMouse.y / iResolution.y - 0.5) * 2.0);\n        ro.xz *= rot((iMouse.x / iResolution.x - 0.5) * 5.0);\n    }\n\n    vec3 f = normalize(ta - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n\n    // Background: Surreal Twilight Gradient\n    vec3 skyTop = vec3(0.1, 0.2, 0.4);\n    vec3 skyBot = vec3(0.8, 0.5, 0.3);\n    vec3 col = mix(skyBot, skyTop, pow(max(0.0, rd.y + 0.2), 0.5));\n    \n    // Sun\n    vec3 sunDir = normalize(vec3(1.0, 0.8, -0.5));\n    float sun = pow(max(0.0, dot(rd, sunDir)), 64.0);\n    col += sun * vec3(1.0, 0.9, 0.6);\n\n    // Raymarching Loop\n    float d = 0.0, total_d = 0.0;\n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * total_d;\n        d = map(p);\n        if(abs(d) < 0.001 || total_d > 40.0) break;\n        total_d += d;\n    }\n\n    if(total_d < 40.0) {\n        vec3 p = ro + rd * total_d;\n        vec3 n = getNormal(p);\n        \n        // Lighting\n        float diff = max(0.0, dot(n, sunDir));\n        float amb = 0.2;\n        float sha = getShadow(p + n * 0.02, sunDir);\n        \n        // Materials\n        vec3 matCol = vec3(0.9, 0.8, 0.6); // Sand/Bone color\n        if(p.y > 0.4 && p.y < 0.6 && length(p.xz) < 2.0) matCol = vec3(0.1, 0.1, 0.1); // Clock Face\n        \n        // Dal's sharp long shadows\n        float lighting = (diff * sha + amb);\n        col = matCol * lighting;\n        \n        // Specular for a \"greasy\" or \"metallic\" look\n        vec3 ref = reflect(rd, n);\n        float spec = pow(max(0.0, dot(ref, sunDir)), 16.0);\n        col += spec * sha * 0.4;\n\n        // Atmospheric haze\n        col = mix(col, skyBot, 1.0 - exp(-0.02 * total_d));\n    }\n\n    // Post processing\n    col = pow(col, vec3(0.8)); // High contrast/saturation\n    col *= 1.1 - dot(uv, uv) * 0.5; // Vignette\n    \n    // Bloom effect simulation\n    col += u_bloom * 0.2 * vec3(1.0, 0.8, 0.4);\n\n    fragColor = vec4(col, 1.0);\n}",
  "parameters": [
    {
      "name": "u_speed",
      "label": "Animation Speed",
      "type": "float",
      "default": 1,
      "min": 0,
      "max": 5
    },
    {
      "name": "u_camera_dist",
      "label": "Viewer Distance",
      "type": "float",
      "default": 8,
      "min": 4,
      "max": 15
    },
    {
      "name": "u_melt_factor",
      "label": "Melting Intensity",
      "type": "float",
      "default": 1,
      "min": 0,
      "max": 3
    },
    {
      "name": "u_bloom",
      "label": "Dream Glow",
      "type": "float",
      "default": 0.5,
      "min": 0,
      "max": 1.5
    }
  ],
  "textureUrl": null
}