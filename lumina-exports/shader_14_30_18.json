{
  "name": "Shader-14:30:18",
  "prompt": "Procedural Shader Snapshot",
  "code": "\n\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec4 iMouse;\nuniform sampler2D iChannel0;\n\n// User Parameters\nuniform float u_speed;\nuniform float u_camera_dist;\nuniform float u_fov;\nuniform float u_glow_intensity;\n\nout vec4 fragColor;\n\n// --- UTILS ---\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Smooth Minimum for organic blending\nfloat smin(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n// Path of the camera/universe\nvec2 getPath(float z) {\n    return vec2(\n        sin(z * 0.15) * 3.5,\n        cos(z * 0.1) * 2.0\n    );\n}\n\n// --- SDF WORLD ---\nfloat map(vec3 p) {\n    // Universe Path offset\n    p.xy -= getPath(p.z);\n    \n    // Twist the space\n    float twist = p.z * 0.1;\n    p.xy *= rot(twist);\n    \n    // Infinite folding mirrors logic\n    vec3 q = p;\n    float scale = 4.0;\n    q = mod(q + scale, scale * 2.0) - scale; // Infinite repetition\n    \n    // Central \"ribbon\" or core structure\n    float core = length(p.xy) - 0.2;\n    \n    // Floating smooth primitives\n    float spheres = length(q) - 0.8;\n    float rings = length(vec2(length(q.xy) - 1.5, q.z)) - 0.1;\n    \n    // Blend it all together for that \"smooth fade\" look\n    float d = smin(core, spheres, 2.5);\n    d = smin(d, rings, 1.5);\n    \n    return d * 0.6; // Step down to prevent artifacts in warped space\n}\n\n// Simple normal calculation\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\n// Palette function for cinematic gradients\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float time = iTime * u_speed;\n    \n    // 1. Path Calculation\n    vec3 pathPos = vec3(0.0, 0.0, time);\n    pathPos.xy += getPath(pathPos.z);\n    \n    // 2. Parallel Rail Camera\n    // Camera orbits the center of the path but moves forward with it\n    float angle = time * 0.2;\n    vec2 railOffset = vec2(cos(angle), sin(angle)) * u_camera_dist;\n    \n    vec3 ro = pathPos;\n    ro.xy += railOffset;\n    \n    // Target looks ahead and slightly inward\n    vec3 ta = vec3(0.0, 0.0, time + 8.0);\n    ta.xy += getPath(ta.z) + railOffset * 0.5;\n    \n    // Camera Basis\n    vec3 fwd = normalize(ta - ro);\n    vec3 right = normalize(cross(vec3(0, 1, 0), fwd));\n    vec3 up = cross(fwd, right);\n    vec3 rd = normalize(fwd * u_fov + uv.x * right + uv.y * up);\n    \n    // 3. Raymarching\n    float d, t = 0.0;\n    float glow = 0.0;\n    \n    for(int i = 0; i < 90; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p);\n        \n        // Accumulate glow based on proximity to objects\n        glow += exp(-d * 3.0) * u_glow_intensity;\n        \n        if(d < 0.001 || t > 50.0) break;\n        t += d;\n    }\n    \n    // 4. Coloring and Shading\n    vec3 col = vec3(0.0);\n    \n    if(t < 50.0) {\n        vec3 p = ro + rd * t;\n        vec3 n = getNormal(p);\n        vec3 lightDir = normalize(vec3(1, 2, -1));\n        \n        // Basic lighting\n        float diff = max(dot(n, lightDir), 0.0);\n        float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 5.0);\n        \n        // Gradient based on distance and depth\n        vec3 baseCol = palette(p.z * 0.05 + time * 0.1);\n        col = baseCol * diff;\n        col += fresnel * baseCol * 2.0; // Rim lighting\n    }\n    \n    // Volumetric / Background Gradient\n    vec3 bgCol = palette(rd.z * 2.0 + time * 0.05) * 0.2;\n    col = mix(col, bgCol, smoothstep(0.0, 50.0, t));\n    \n    // Add the glow \"Aura\"\n    col += palette(t * 0.1 + time * 0.2) * glow * 0.02;\n    \n    // 5. Post Processing\n    // Contrast and Bloom-ish feel\n    col = smoothstep(-0.1, 1.1, col);\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    \n    // Vignette\n    float vig = 1.0 - dot(uv, uv) * 0.4;\n    col *= vig;\n\n    fragColor = vec4(col, 1.0);\n}",
  "parameters": [
    {
      "name": "u_speed",
      "label": "Fly Speed",
      "type": "float",
      "default": 2,
      "min": 0,
      "max": 5
    },
    {
      "name": "u_camera_dist",
      "label": "Orbit Radius",
      "type": "float",
      "default": 6,
      "min": 2,
      "max": 12
    },
    {
      "name": "u_fov",
      "label": "Field of View",
      "type": "float",
      "default": 1.2,
      "min": 0.5,
      "max": 2.5
    },
    {
      "name": "u_glow_intensity",
      "label": "Glow Power",
      "type": "float",
      "default": 0.5,
      "min": 0,
      "max": 1.5
    }
  ],
  "textureUrl": null
}