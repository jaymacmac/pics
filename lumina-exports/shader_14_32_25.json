{
  "name": "Shader-14:32:25",
  "prompt": "Procedural Shader Snapshot",
  "code": "\n\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec4 iMouse;\nuniform sampler2D iChannel0;\n\n// User Parameters\nuniform float u_speed;\nuniform float u_complexity;\nuniform float u_camera_dist;\nuniform float u_glow_intensity;\n\nout vec4 fragColor;\n\n// --- UTILS ---\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Hyper-complex Gyroid structure\nfloat gyroid(vec3 p, float scale, float thickness, float bias) {\n    p *= scale;\n    return abs(dot(sin(p), cos(p.zxy)) - bias) / scale - thickness;\n}\n\n// Path for the \"Infinity\" camera rail\nvec2 getPath(float z) {\n    return vec2(sin(z * 0.2) * 3.0, cos(z * 0.15) * 2.5);\n}\n\n// --- MAP ---\nfloat map(vec3 p) {\n    // 1. Follow the path\n    p.xy -= getPath(p.z);\n    \n    // 2. The \"Bowtie\" twisting space\n    float twist = p.z * 0.2;\n    p.xy *= rot(twist);\n    \n    // Create the Bowtie core shape using a distorted cylinder/box hybrid\n    vec3 p_core = p;\n    float angle = atan(p_core.y, p_core.x);\n    float r = length(p_core.xy);\n    \n    // Bowtie expansion logic\n    float bowtie = r - (1.5 + 2.5 * pow(abs(sin(angle)), 2.0));\n    \n    // 3. Gyroid Infill (The fractal lattice)\n    // We use multiple octaves of gyroids for high detail\n    float g1 = gyroid(p, u_complexity, 0.03, 0.5);\n    float g2 = gyroid(p, u_complexity * 2.1, 0.01, 0.2);\n    float g_final = max(g1, -g2); // Create hollowed out structure\n    \n    // Combine bowtie shell and gyroid\n    float d = max(bowtie, g_final);\n    \n    // Add some outer floating bits\n    float outer = gyroid(p * 0.5, 1.2, 0.05, 1.2);\n    d = min(d, outer);\n\n    return d * 0.6; // Step scale for stability\n}\n\n// Raymarching Normals\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float time = iTime * u_speed;\n\n    // --- PARALLEL RAIL CAMERA ---\n    vec3 pathPos = vec3(0.0, 0.0, time);\n    pathPos.xy += getPath(pathPos.z);\n    \n    // Rail rotation for \"Orbit\"\n    float railRot = time * 0.2;\n    vec2 railVec = vec2(sin(railRot), cos(railRot)) * u_camera_dist;\n    \n    vec3 ro = pathPos;\n    ro.xy += railVec;\n    \n    // Target is ahead on the rail\n    vec3 ta = vec3(0.0, 0.0, time + 4.0);\n    ta.xy += getPath(ta.z) + railVec * 0.7; // Look slightly inward to the bowtie\n    \n    // LookAt Matrix\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(time * 0.1), 1.0, 0.0); // Slight roll\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = normalize(uv.x * cu + uv.y * cv + 1.2 * cw);\n\n    // --- MARCHING ---\n    float t = 0.0;\n    float maxDist = 40.0;\n    float glow = 0.0;\n    float hit = 0.0;\n    \n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        \n        // Accumulate glow based on proximity to surface\n        glow += exp(-d * 4.0); \n        \n        if(d < 0.001) {\n            hit = 1.0;\n            break;\n        }\n        if(t > maxDist) break;\n        t += d;\n    }\n\n    // --- SHADING ---\n    vec3 col = vec3(0.0);\n    \n    if(hit > 0.0) {\n        vec3 p = ro + rd * t;\n        vec3 n = getNormal(p);\n        vec3 ref = reflect(rd, n);\n        \n        // Fresnel and Lighting\n        float fre = pow(clamp(1.0 + dot(rd, n), 0.0, 1.0), 3.0);\n        float occ = clamp(map(p + n * 0.2) / 0.2, 0.0, 1.0);\n        \n        // Distance-based coloring (Cycles through hues along Z)\n        vec3 baseCol = 0.5 + 0.5 * cos(vec3(0.0, 1.0, 2.0) + p.z * 0.15 + time * 0.5);\n        \n        col = baseCol * (0.2 + 0.8 * occ); // Ambient + Occ\n        col += pow(fre, 2.0) * vec3(0.5, 0.8, 1.0); // Specular/Fresnel\n        \n        // Deep shadows\n        col *= exp(-0.05 * t);\n    }\n    \n    // Apply Glow (Neon Infinity vibe)\n    vec3 glowCol = 0.5 + 0.5 * cos(vec3(0.5, 0.2, 0.9) + time * 0.3);\n    col += glowCol * glow * 0.02 * u_glow_intensity;\n    \n    // Background fog\n    col = mix(col, vec3(0.02, 0.01, 0.05), 1.0 - exp(-0.02 * t));\n\n    // Post-process\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    col *= 1.0 - dot(uv, uv) * 0.4; // Vignette\n    \n    fragColor = vec4(col, 1.0);\n}",
  "parameters": [
    {
      "name": "u_speed",
      "label": "Fly Speed",
      "type": "float",
      "default": 2.5,
      "min": 0,
      "max": 8
    },
    {
      "name": "u_complexity",
      "label": "Gyroid Density",
      "type": "float",
      "default": 1.2,
      "min": 0.5,
      "max": 3
    },
    {
      "name": "u_camera_dist",
      "label": "Rail Offset",
      "type": "float",
      "default": 6.5,
      "min": 3,
      "max": 12
    },
    {
      "name": "u_glow_intensity",
      "label": "Glow Strength",
      "type": "float",
      "default": 1.5,
      "min": 0,
      "max": 5
    }
  ],
  "textureUrl": null
}