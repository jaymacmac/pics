{
  "name": "Shader-13:03:28",
  "prompt": "Procedural Shader Snapshot",
  "code": "\n\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec4 iMouse;\nuniform sampler2D iChannel0;\n\n// User Parameters\nuniform float u_speed;\nuniform float u_camera_dist;\nuniform float u_glow_intensity;\nuniform float u_complexity;\n\nout vec4 fragColor;\n\n#define MAX_STEPS 100\n#define SURF_DIST 0.001\n#define MAX_DIST 50.0\n\n// Rotation matrix\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// 3D Noise function for organic displacement\nfloat noise(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\n// Smooth Minimum for organic blending\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// The \"Universe Path\" - defining the dream-like drift\nvec2 getPath(float z) {\n    return vec2(\n        sin(z * 0.2) * 2.0 + cos(z * 0.1) * 1.5,\n        cos(z * 0.15) * 2.0 + sin(z * 0.05) * 1.0\n    );\n}\n\n// SDF of the scene\nfloat map(vec3 p) {\n    // Offset the entire world based on the path\n    p.xy -= getPath(p.z);\n    \n    // Create floating \"bio-orbs\" and organic structures\n    vec3 p_orbs = p;\n    float z_idx = floor(p_orbs.z / 4.0);\n    p_orbs.z = mod(p_orbs.z, 4.0) - 2.0;\n    \n    // Twist effect\n    p_orbs.xy *= rot(p.z * 0.2 + iTime * 0.2);\n    \n    // Central bioluminescent \"Core\" strand\n    float core = length(p.xy + vec2(sin(p.z), cos(p.z * 0.5)) * 0.5) - 0.2;\n    \n    // Fractal-like organic growth\n    float d = 1e10;\n    for(float i = 0.0; i < 3.0; i++) {\n        vec3 p_fract = p_orbs;\n        p_fract.xy *= rot(i * 1.5 + iTime * 0.1);\n        p_fract.x += sin(p.z * 0.8 + i) * 1.2;\n        \n        float sphere = length(p_fract) - (0.4 + 0.2 * sin(p.z + iTime));\n        d = smin(d, sphere, 0.8);\n    }\n    \n    // Combine core and fractal orbs\n    return smin(d, core, 1.5);\n}\n\n// Normal calculation\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    vec3 n = map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nvoid main() {\n    // Correct Aspect Ratio UVs\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float t = iTime * u_speed;\n    \n    // --- CAMERA STRATEGY (PARALLEL RAIL) ---\n    // 1. Path Position\n    vec3 pathPos = vec3(0.0, 0.0, t);\n    pathPos.xy += getPath(pathPos.z);\n    \n    // 2. Rail Offset (Orbiting the path)\n    float orbitSpeed = iTime * 0.1;\n    vec2 railVec = vec2(cos(orbitSpeed), sin(orbitSpeed)) * u_camera_dist;\n    \n    // Camera is on the rail\n    vec3 ro = pathPos;\n    ro.xy += railVec;\n    \n    // Look Target is also offset to maintain the \"Side-Along\" view\n    vec3 ta = vec3(0.0, 0.0, t + 8.0);\n    ta.xy += getPath(ta.z) + railVec * 0.5; // Look slightly inward to the central path\n    \n    // Camera Setup\n    vec3 f = normalize(ta - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n    \n    // Raymarching\n    float d = 0.0;\n    float glow = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * d;\n        float ds = map(p);\n        d += ds;\n        \n        // Volumetric Bioluminescence accumulation\n        glow += exp(-ds * 4.0) * u_glow_intensity;\n        \n        if(d > MAX_DIST || ds < SURF_DIST) break;\n    }\n    \n    // Shading\n    vec3 col = vec3(0.0);\n    \n    // Deep underwater/void blue background\n    vec3 background = vec3(0.02, 0.04, 0.1) * (1.0 - length(uv));\n    \n    if(d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n        \n        // Fresnel / Rim lighting\n        float fresnel = pow(1.0 + dot(rd, n), 4.0);\n        \n        // Organic bioluminescent color palette\n        vec3 bioColor = mix(\n            vec3(0.0, 1.0, 0.8), // Cyan/Teal\n            vec3(0.6, 0.1, 1.0), // Purple/Neon\n            sin(p.z * 0.2 + iTime) * 0.5 + 0.5\n        );\n        \n        col = bioColor * fresnel * 2.0;\n        col += bioColor * 0.2; // Base ambient\n    }\n    \n    // Add glow\n    vec3 glowColor = mix(vec3(0.1, 0.4, 0.8), vec3(0.8, 0.2, 0.9), sin(iTime * 0.5) * 0.5 + 0.5);\n    col += glowColor * glow * 0.15;\n    \n    // Distance fog\n    col = mix(col, background, smoothstep(0.0, MAX_DIST, d));\n    \n    // Cinematic Post Processing\n    col = pow(col, vec3(0.8)); // Gamma correction\n    col *= 1.2; // Exposure\n    \n    // Vignette\n    float vig = 1.0 - dot(uv, uv) * 0.5;\n    col *= vig;\n\n    fragColor = vec4(col, 1.0);\n}",
  "parameters": [
    {
      "name": "u_speed",
      "label": "Fly Speed",
      "type": "float",
      "default": 1.5,
      "min": 0,
      "max": 5
    },
    {
      "name": "u_camera_dist",
      "label": "Orbit Distance",
      "type": "float",
      "default": 7,
      "min": 4,
      "max": 12
    },
    {
      "name": "u_glow_intensity",
      "label": "Bioluminescence",
      "type": "float",
      "default": 0.8,
      "min": 0.1,
      "max": 2
    },
    {
      "name": "u_complexity",
      "label": "Fractal Depth",
      "type": "float",
      "default": 3,
      "min": 1,
      "max": 6
    }
  ],
  "textureUrl": null
}