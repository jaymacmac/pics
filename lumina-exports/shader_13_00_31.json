{
  "name": "Shader-13:00:31",
  "prompt": "Procedural Shader Snapshot",
  "code": "\n\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec4 iMouse;\nuniform sampler2D iChannel0;\n\n// User Parameters\nuniform float u_speed;\nuniform float u_fov;\nuniform float u_camera_dist;\nuniform float u_morph;\n\nout vec4 fragColor;\n\n#define MAX_STEPS 100\n#define SURF_DIST 0.001\n#define MAX_DIST 50.0\n\n// Rotation matrix\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Smooth Minimum for organic blending\nfloat smin(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n// Fractal noise for surface detailing\nfloat noise(vec3 p) {\n    p *= 0.5;\n    float res = 0.0;\n    float amp = 0.5;\n    for(int i = 0; i < 3; i++) {\n        p.xy *= rot(0.5);\n        p.yz *= rot(0.3);\n        res += amp * abs(sin(p.x + sin(p.y + sin(p.z))));\n        amp *= 0.5;\n        p *= 2.1;\n    }\n    return res;\n}\n\n// Infinite path for the universe\nvec2 getPath(float z) {\n    return vec2(\n        sin(z * 0.15) * 3.0 + cos(z * 0.08) * 2.0,\n        cos(z * 0.12) * 2.5 + sin(z * 0.05) * 1.5\n    );\n}\n\n// Distance Function\nfloat map(vec3 p) {\n    vec2 path = getPath(p.z);\n    p.xy -= path; // Universe bending\n    \n    // The \"Surreal Spine\" - Central Structure\n    vec3 p1 = p;\n    p1.xy *= rot(p.z * 0.2 + iTime * 0.2);\n    \n    // Rib-like structures\n    float ribs = length(p1.xy + vec2(sin(p1.z * 2.0)*0.5, 0.0)) - 0.4;\n    ribs = max(ribs, abs(mod(p1.z, 1.5) - 0.75) - 0.1);\n    \n    // Floating Orbs\n    vec3 p2 = p;\n    p2.z = mod(p2.z, 10.0) - 5.0;\n    p2.x += sin(iTime + p.z * 0.1) * 2.0;\n    p2.y += cos(iTime * 0.8) * 2.0;\n    float orbs = length(p2) - (1.2 + 0.5 * sin(iTime * 2.0 + p.z));\n    \n    // Infinite \"Veins\" / Cables\n    vec3 p3 = p;\n    p3.xy *= rot(0.78);\n    vec2 g = abs(mod(p3.xy, 6.0)) - 3.0;\n    float veins = length(g) - 0.1 - noise(p * 0.5) * 0.2;\n    \n    // Morphing blend\n    float scene = smin(ribs, orbs, 1.5);\n    scene = smin(scene, veins, 0.8);\n    \n    return scene * 0.6; // Step scaling for detail\n}\n\n// Raymarching Loop\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = map(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    return dO;\n}\n\n// Normal Calculation\nvec3 getNormal(vec3 p) {\n    float d = map(p);\n    vec2 e = vec2(0.01, 0.0);\n    vec3 n = d - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float t = iTime * u_speed;\n    \n    // Parallel Rail Camera Logic\n    vec3 pathPos = vec3(0.0, 0.0, t);\n    pathPos.xy += getPath(pathPos.z);\n    \n    // Circular orbit around the central path\n    vec2 railVec = vec2(sin(t * 0.2), cos(t * 0.2)) * u_camera_dist;\n    \n    vec3 ro = pathPos;\n    ro.xy += railVec;\n    \n    vec3 ta = vec3(0.0, 0.0, t + 10.0);\n    ta.xy += getPath(ta.z) + railVec * 0.5; // Follow the rail's general direction\n    \n    // Camera Transform\n    vec3 f = normalize(ta - ro);\n    vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), f));\n    vec3 u = cross(f, r);\n    vec3 rd = normalize(f * u_fov + uv.x * r + uv.y * u);\n    \n    // Rendering\n    float d = rayMarch(ro, rd);\n    vec3 col = vec3(0.0);\n    \n    if(d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n        vec3 r_dir = reflect(rd, n);\n        \n        // Lighting\n        float diffuse = dot(n, normalize(vec3(1, 2, 3))) * 0.5 + 0.5;\n        float spec = pow(max(0.0, dot(r_dir, normalize(vec3(1, 2, 3)))), 32.0);\n        float fresnel = pow(1.0 - max(0.0, dot(n, -rd)), 5.0);\n        \n        // Coloring based on depth and position\n        vec3 baseCol = 0.5 + 0.4 * cos(p.z * 0.1 + vec3(0, 2, 4));\n        baseCol *= (1.0 - noise(p * 0.1));\n        \n        col = baseCol * diffuse;\n        col += spec * 0.5;\n        col += vec3(0.2, 0.5, 0.9) * fresnel; // Ethereal glow\n        \n        // Ambient Occlusion (fake)\n        float ao = clamp(map(p + n * 0.5) / 0.5, 0.0, 1.0);\n        col *= ao;\n    }\n    \n    // Volumetric Fog and Background\n    float fog = 1.0 - exp(-d * 0.04);\n    vec3 skyCol = vec3(0.02, 0.01, 0.05) + 0.05 * vec3(sin(t*0.1), 0.0, cos(t*0.15));\n    col = mix(col, skyCol, fog);\n    \n    // Post Processing\n    col = pow(col, vec3(0.8)); // Gamma\n    col *= 1.2 - length(uv) * 0.5; // Vignette\n    \n    fragColor = vec4(col, 1.0);\n}",
  "parameters": [
    {
      "name": "u_speed",
      "label": "Fly Speed",
      "type": "float",
      "default": 2.5,
      "min": 0,
      "max": 10
    },
    {
      "name": "u_fov",
      "label": "Field of View",
      "type": "float",
      "default": 1.2,
      "min": 0.5,
      "max": 3
    },
    {
      "name": "u_camera_dist",
      "label": "Rail Offset",
      "type": "float",
      "default": 7,
      "min": 3,
      "max": 15
    },
    {
      "name": "u_morph",
      "label": "Morph Intensity",
      "type": "float",
      "default": 1,
      "min": 0,
      "max": 2
    }
  ],
  "textureUrl": null
}