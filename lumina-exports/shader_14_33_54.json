{
  "name": "Shader-14:33:54",
  "prompt": "Procedural Shader Snapshot",
  "code": "uniform float iTime;\nuniform vec2 iResolution;\nuniform vec4 iMouse;\nuniform sampler2D iChannel0;\n\n// User Parameters\nuniform float u_speed;\nuniform float u_camera_dist;\nuniform float u_fov;\nuniform float u_twist;\nuniform float u_thickness;\nuniform float u_glow_intensity;\n\nout vec4 fragColor;\n\n// --- Utilities ---\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// --- Path Generation ---\n// The \"Infinity\" Bowtie logic in 3D\nvec3 getBowtiePos(float t) {\n    float angle = t * 0.5;\n    // Lemniscate of Bernoulli formula\n    float scale = 8.0;\n    float denom = 1.0 + pow(sin(angle), 2.0);\n    float x = (scale * cos(angle)) / denom;\n    float y = (scale * sin(angle) * cos(angle)) / denom;\n    float z = sin(t * 0.2) * 2.0; // Slow vertical oscillation\n    return vec3(x, y, z);\n}\n\n// Distance Function\nfloat map(vec3 p) {\n    float t = iTime * u_speed * 0.2;\n    \n    // We sample multiple points along the \"infinity\" loop to create a continuous tube\n    float d = 1e10;\n    \n    // Procedural twist and weave\n    float twist = p.z * u_twist + iTime;\n    \n    // To make it look like a \"Bowtie\", we evaluate the SDF against the infinity curve\n    // For performance in a fragment shader, we approximate the curve distance\n    for(float i = 0.0; i < 1.0; i += 0.1) {\n        float sampleT = t + i * 6.2831;\n        vec3 curvePos = getBowtiePos(sampleT);\n        \n        // Add some local variation/noise to the tube\n        float localDist = length(p - curvePos);\n        \n        // Interior energy \"ribbons\" logic\n        vec3 q = p - curvePos;\n        q.xy *= rot(sampleT * 2.0 + iTime);\n        float ribbon = length(q.xy) - u_thickness * (0.8 + 0.4 * sin(q.z * 5.0 + iTime * 2.0));\n        \n        d = smin(d, ribbon, 1.5);\n    }\n    \n    return d;\n}\n\n// Normal calculation\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float globalTime = iTime * u_speed;\n    \n    // --- Parallel Rail Camera Strategy ---\n    // 1. Position on the infinity loop\n    vec3 pathPos = getBowtiePos(globalTime * 0.5);\n    \n    // 2. Camera Rail Offset\n    // The camera orbits the current path position at u_camera_dist\n    float angle = globalTime * 0.1;\n    vec3 railVec = vec3(cos(angle), sin(angle), sin(angle * 0.5)) * u_camera_dist;\n    \n    vec3 ro = pathPos + railVec;\n    \n    // 3. Target (Look slightly ahead on the path)\n    vec3 ta = getBowtiePos(globalTime * 0.5 + 0.5) + railVec * 0.5;\n    \n    // Camera Transform\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = normalize(uv.x * cu + uv.y * cv + u_fov * cw);\n\n    // --- Raymarching ---\n    float t = 0.0;\n    float d = 0.0;\n    float glow = 0.0;\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 80; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p);\n        \n        // Accumulate glow based on proximity to surface\n        glow += 0.01 / (0.05 + d * d);\n        \n        if(d < 0.001 || t > 40.0) break;\n        t += d * 0.6; // Slightly conservative step for smooth curves\n    }\n\n    // --- Shading ---\n    if(d < 0.1) {\n        vec3 p = ro + rd * t;\n        vec3 n = getNormal(p);\n        vec3 ref = reflect(rd, n);\n        \n        // Fresnel\n        float fres = pow(1.0 + dot(rd, n), 3.0);\n        \n        // Base Color: Iridescent Blues/Purples\n        vec3 baseCol = 0.5 + 0.5 * cos(vec3(0, 2, 4) + p.z * 0.2 + iTime);\n        \n        // Lighting\n        float diff = max(dot(n, normalize(vec3(1, 2, 3))), 0.0);\n        float spec = pow(max(dot(ref, normalize(vec3(1, 2, 3))), 0.0), 32.0);\n        \n        col = baseCol * diff + spec + fres * baseCol;\n        \n        // Add \"Energy Weave\" texture\n        vec3 tex = texture(iChannel0, p.xz * 0.1 + iTime * 0.05).rgb;\n        col += tex * 0.2;\n    }\n    \n    // Volumetric Atmosphere\n    vec3 glowCol = 0.5 + 0.5 * cos(vec3(1, 3, 5) + globalTime * 0.3);\n    col += glow * glowCol * u_glow_intensity;\n    \n    // Background stars/dust\n    float stars = pow(fract(sin(dot(rd, vec3(12.9898, 78.233, 45.164))) * 43758.5453), 20.0);\n    col += stars * 0.1 * (1.0 - smoothstep(0.0, 30.0, t));\n\n    // Tonemapping & Contrast\n    col = smoothstep(0.0, 1.1, col);\n    col = pow(col, vec3(0.85)); // Gamma correction-ish\n\n    fragColor = vec4(col, 1.0);\n}",
  "parameters": [
    {
      "name": "u_speed",
      "label": "Animation Speed",
      "type": "float",
      "default": 1,
      "min": 0,
      "max": 4
    },
    {
      "name": "u_camera_dist",
      "label": "Camera Rail Dist",
      "type": "float",
      "default": 8,
      "min": 3,
      "max": 15
    },
    {
      "name": "u_fov",
      "label": "Field of View",
      "type": "float",
      "default": 1.2,
      "min": 0.5,
      "max": 2.5
    },
    {
      "name": "u_twist",
      "label": "Geometry Twist",
      "type": "float",
      "default": 0.5,
      "min": 0,
      "max": 2
    },
    {
      "name": "u_thickness",
      "label": "Strand Thickness",
      "type": "float",
      "default": 0.4,
      "min": 0.1,
      "max": 1.5
    },
    {
      "name": "u_glow_intensity",
      "label": "Bloom Intensity",
      "type": "float",
      "default": 0.15,
      "min": 0,
      "max": 0.5
    }
  ],
  "textureUrl": null
}